%%%%%%%%%%%%%%%%%%%% Juego
\section{TAD \tadNombre{Juego}}
\begin{tad}{\tadNombre{Juego}}
	\tadGeneros{juego}
	
	%%% Observadores %%%
	\tadObservadores
	\tadAlinearFunciones{cuantoLlevaEsperando~}{Jugador/j, Juego/pGo, Coordenada}
	
    \tadOperacion{mapa}{Juego}{Mapa}{}
    \tadOperacion{jugadores}{Juego}{Jugadores}{}
    \tadOperacion{posicionJugador}{Jugador/j, Juego/pGo}{Coordenada}
    	{def?(j, jugadores(pGo)) $\yluego$ estaConectado(j,pGo)}
    \tadOperacion{pokemones}{Juego}{Pokemones}{}
    \tadOperacion{posicionPokemon}{Pokemon/p, Juego/pGo}{Coordenada}
    		{def?($\Pi_1$(p),pokemones(pGo)) $\yluego$ esSalvaje?(p, pGo)}
    \tadOperacion{cuantoLlevaEsperando}{Pokemon/p, Juego/pGo}{Nat}{def?($\Pi_1$(p),pokemones(pGo)) $\yluego$ esSalvaje?(p, pGo)}
    \tadOperacion{pokemonesAtrapados}{Jugador/j, Juego/pGo}{Pokemones}{def?(j, jugadores(pGo))}
    \tadOperacion{cantidadDeSanciones}{Jugador/j, Juego/pGo}{Nat}{def?(j, jugadores(pGo))}

	%%% Generadores %%%
	\tadGeneradores
	\tadAlinearFunciones{moverJugador~}{Jugador/j, Coordenada/c, Juego/pGo, Juego}
	
    \tadOperacion{nuevoJuego}{Mapa}{Juego}{}{}
    \tadOperacion{agJugador}{Jugador/j, Coordenada/c, Juego/pGo}{Juego}
    	{$\neg$ def?(j, jugadores(pGo)) $\yluego$ esPosicionValidaMapa(c, pGo) }
    \tadOperacion{agPokemon}{Pokemon/p, Coordenada/c, Juego/pGo}{Juego}
    	{$\neg$ def?($\Pi_1$(p),pokemones(pGo)) $\yluego$ esPosicionValidaPokemon(c, pGo)}
    \tadOperacion{moverJugador}{Jugador/j, Coordenada/c, Juego/pGo}{Juego}
    	{def?(j, jugadores(pGo)) $\yluego$ esPosicionValidaMapa(c, pGo) $\yluego$ estaConectado(j,pGo) $\yluego$ posicionJugador(j) $\neq$ c }
    \tadOperacion{conectar}{Jugador/j, Coordenada/c, Juego/pGo}{Juego}{def?(j, jugadores(pGo)) $\yluego$ $\neg$ estaConectado(j,pGo) $\wedge$ esPosicionValidaMapa(c, pGo)}
    \tadOperacion{desconectar}{Jugador/j, Juego/pGo}{Juego}{def?(j, jugadores(pGo)) $\yluego$ estaConectado(j,pGo)}
    %% moverJugador automaticamente se conecta
    	
    %%% Otras Operaciones %%%
    \tadOtrasOperaciones
    \tadAlinearFunciones{estaEnElRangoDeOtroPokemon~}{Pokemon/p, Jugador/j, Mapa/m, Juego}
    \tadOperacion{esPosicionValidaMapa}{Coordenada/c, Juego/pGo}{bool}{}
    \tadOperacion{esPosicionValidaPokemon}{Coordenada/c, Juego/pGo}{bool}{}
%    \tadOperacion{actualizarContadores}{conj(Jugador)/cj, Coordenada/c, Juego pGo}{conj(Jugador)}{}
%    \tadOperacion{borrarPokemones}{Pokemones/p, conj(Nat)/ids}{Pokemones}{}
%	\tadOperacion{unoAtrapa}{conj(Jugador)/js, Juego/pGo}{conj(Jugador)}{js $\subseteq$ jugadores(pGo)}
%	\tadOperacion{posicionJugadores}{Coordenada/c, Juegao/pGo}{conj(Jugador)}{c $\in$ posiciones(mapa(pGo))}  
	\tadOperacion{esSalvaje?}{Pokemon/p, Juego/pGo}{Bool}{def?($\Pi_1$(p),pokemones(pGo))}    
    \tadOperacion{estaEnRangoDeAtrapar}{Jugador/j, Juego/pGo}{Bool}{def?(j, jugadores(pGo))} %te dice si el jugador esta dentro del rango de algun pokemon
	\tadOperacion{pokemonDelRango}{Jugador/j, Juego/pGo}{Pokemon}{def?(j, jugadores(pGo)) $\yluego$ estaEnRangoDeAtrapar(j,pGo)} %FaltanRestricciones si el j esta en rango de atrapar, te devuelve el pokemon en cuestiÃ³n.    
    \tadOperacion{jugadoresDelRango}{Coordenada/c, Juego/pGo}{Conj(Jugador)}{esPosicionValidaMapa(c, pGo)}
    \tadOperacion{estaEnElRangoDeOtroPokemon}{Coordenada/c1, Coordenada/c2, Mapa/m}{Bool}{}
    \tadOperacion{restaAbsoluta}{Nat/n1, Nat/n2}{Nat}{}
    \tadOperacion{rareza}{Tipo/t, Juego/pGo}{Nat}{estaDefTipo(t,pGo)}        
    \tadOperacion{cantidadPokemonesTipo}{Tipo/t, Conj(Nat)/ids, Juego/pGo}{Nat}{estaDefTipo(t,pGo)}
    \tadOperacion{dividir}{Nat/n, Nat/d}{Nat}{$\neg$(d = 0?)}
    
	%%% Axiomas %%%
	\tadAxiomas[\paratodo{Mapa}{m} \paratodo{Jugador}{j,j1,j2} \paratodo{Coordenada}{c} \paratodo{Juego}{pGo} \paratodo{Pokemon}{p} \paratodo{Nat}{n} \paratodo{Tipo}{t}]
	\tadAlinearAxiomas{pokemonesAtrapados(j1, moverJugador(j2, c, pGo))}

	%%% nuevoJuego
	\tadAxioma{mapa(nuevoJuego(m))}{m}
	\tadAxioma{jugadores(nuevoJuego(m))}{$\emptyset$}
	\tadAxioma{pokemones(nuevoJuego(m))}{$\emptyset$}

	$\newline$
	%%% agJugador ==> ver si tiene que informar posicion
	\tadAxioma{mapa(agJugador(j, c, pGo))}{mapa(pGo)}
	\tadAxioma{jugadores(agJugador(j, c, pGo))}{Ag(j, jugadores(pGo))}
	\tadAxioma{posicionJugador(j1, agJugador(j2, c, pGo))}{\IF j1 = j2 THEN c ELSE posicionJugador(j1, pGo) FI}
	\tadAxioma{pokemones(agJugador(j, c, pGo))}{pokemones(pGo)}
	\tadAxioma{posicionPokemon(p, agJugador(j, c, pGo))}{posicionPokemon(p, pGo)}
  	\tadAxioma{cuantoLlevaEsperando(p,agJugador(j, c, pGo))}{\IF estanEnElMismoRango(posicionPokemon(p,pGo), c, mapa(pGo)) THEN 0 ELSE cuantoLLevaEsperando(p, pGo) + 1 FI} 
  \tadAxioma{pokemonesAtrapados(j1, agJugador(j2, c, pGo))}{\IF j1 == j2 THEN vacio ELSE {\IF estanEnMismoRango(posicionJugador(j1, pGo), c, pGo) THEN pokemonesAtrapados(j1, pGo) ELSE {\IF cuantoLlevaEsperando(pokemonEnRango(rangoDeCaza(j1, pGo), pGo), pGo) = 9 THEN {\IF j1 = dameUno(jugadoresPorAtrapar(pokemonEnRango(rangoDeCaza(j1, pGo), pGo))) THEN definir($\Pi_1$(pokemonEnRango(rangoDeCaza(j1, pGo), pGo)), $\Pi_2$(pokemonEnRango(rangoDeCaza(j1, pGo)), pGo), pokemonesAtrapados(j1, pGo)) ELSE pokemonesAtrapados(j1, pGo) FI} ELSE pokemonesAtrapados(j1, pGo) FI} FI} FI}
  \tadAxioma{cantidadDeSanciones(j1, agJugador(j2, c, pGo))}{\IF j1 == j2 THEN 0 ELSE cantidadDeSanciones(j1) FI}
  
  	$\newline$
	%%% agPokemon
	\tadAxioma{mapa(agPokemon(p, c, pGo))}{mapa(pGo)}
	\tadAxioma{jugadores(agPokemon(p, c, pGo))}{jugadores(pGo)}
	\tadAxioma{posicionJugador(j, agPokemon(p, c, pGo))}{posicionJugador(j, pGo)}
	\tadAxioma{pokemones(agPokemon(p, c, pGo))}{definir($\Pi_1$(p), $\Pi_2$(p), pokemones(pGo))}
	\tadAxioma{posicionPokemon(p1, agPokemon(p2, c, pGo))}{\IF p1 = p2 THEN c ELSE posicionPokemon(p1, pGo) FI}
	\tadAxioma{cuantoLlevaEsperando(p1, agPokemon(p2, c, pGo))}{\IF p1 = p2 THEN 0 ELSE cuantoLlevaEsperando(p1, pGo) FI}
	\tadAxioma{pokemonesAtrapados(j, agPokemon(p, c, pGo))}{pokemonesAtrapados(j, pGo)}
	\tadAxioma{cantidadDeSanciones(j, agPokemon(p, c, pGo))}{cantidadDeSanciones(j, pGo)}
	
	$\newline$
	%%% moverJugador
	\tadAxioma{mapa(moverJugador(j, c, pGo))}{mapa(pGo)}
	%%Agregar movimientoInvalido al tad Mapa
	\tadAxioma{jugadores(moverJugador(j,c,pGo))}{\IF movimientoInvalido(posicionJugador(j,pGo),c,mapa(pGo)) THEN {\IF cantidadDeSanciones(j,pGo) = 4 THEN borrar(j,jugadores(pGo)) ELSE jugadores(pGo) FI} ELSE jugadores(pGo) FI}
	\tadAxioma{posicionJugador(j1, moverJugador(j2,c,pGo))}{\IF j1 = j2 THEN c ELSE posicionJugador(j1,pGo) FI}
	%%sacarPokemones tiene que sacar esas claves de pokemones y devolver el diccionario sin esos pokemones
	\tadAxioma{pokemones(moverJugador(j,c,pGo))}{\IF movimientoInvalido(posicionJugador(j,pGo),c,mapa(pGo)) THEN {\IF cantidadDeSanciones(j,pGo) = 4 THEN sacarPokemones(claves(pokemonesAtrapados(j,pGo)),pGo) ELSE pokemones(pGo) FI} ELSE pokemones(pGo) FI}
	\tadAxioma{posicionPokemon(p,moverJugador(j,c,pGo))}{posicionPokemon(pGo)}
	\tadAxioma{cuantoLlevaEsperando(p,moverJugador(j,c,pGo))}{\IF estanEnElMismoRango(posicionPokemon(p,pGo),posicionJugador(j,pGo),mapa(pGo)) THEN {\IF estanEnElMismoRango(posicionPokemon(p,pGo),c,mapa(pGo)) THEN cuantoLlevaEsperando(p,pGo) ELSE cuantoLlevaEsperando(p,pGo) + 1 FI} ELSE {\IF estanEnElMismoRango(posicionPokemon(p,pGo),c,mapa(pGo)) THEN 0 ELSE cuantoLlevaEsperando(p,pGo) + 1 FI} FI}
	\tadAxioma{cantidadDeSanciones(j1,moverJugador(j2,c,pGo))}{\IF j1 = j2 THEN {\IF movientoInvalido(poscionJugador(j1),c,pGo) THEN cantidadDeSanciones(j1,pGo) + 1 ELSE cantidadDeSanciones(j1,pGo) FI} ELSE cantidadDeSanciones(j1,pGo) FI}	
	%%% ver otra op posicionInvalida, puede ser esPosicionValida declarada arriba
%	\tadAxioma{jugadores(moverJugador(j, c, pGo))}{\IF nula?(c) THEN jugadores(pGo) ELSE actualizarContadores({\IF posicionInvalida(posicionJugador(j, pGo), c, pGo) THEN {\IF cantidadSanciones(j) = 4 THEN jugadores(pGo) - {j} ELSE Ag(sancionar(j), jugadores(pGo) - {j}) FI} ELSE jugadores(pGo) FI}, c, pGo) FI}
%	\tadAxioma{posicionJugador(j1, moverJugador(j2, c, pGo))}{\IF j1 $\neq$ j2 THEN posicionJugador(j1, pGo) ELSE {\IF nula?(c) THEN fueraDelMapa ELSE {\IF nula?(posicionJugador(j2, pGo)) THEN c ELSE {\IF posicionInvalida(c) THEN {\IF cantidadDeSanciones(j1) = 4 THEN fueraDelMapa ELSE c FI} ELSE c FI} FI} FI} FI}
%	\tadAxioma{pokemones(moverJugador(j, c, pGo))}{\IF nula?(c) THEN pokemones(pGo) ELSE {\IF (posicionInvalida(posicionJugador(j, pGo), c, pGo) $\land$ cantidadSanciones(j) = 4) THEN borrarPokemones(pokemones(pGo), claves(pokedex(j))) ELSE pokemones(pGo) FI} FI}
 %   \tadAxioma{borrarPokemones(p, ids}{\IF vacio?(ids) THEN p ELSE borrarPokemones(borrar(dameUno(ids), p), sinUno(ids)) FI}
    
%    \tadAxioma{posicionPokemon(p, moverJugador(j, c, pGo))}{\IF nula?(c) THEN posicionPokemon(p, pGo) ELSE {\IF j $\in$ posicionJugadores(posicionPokemon(p, pGo), pGo) THEN posicionPokemon(p, pGo) ELSE {\IF esperaParaAtrapar(dameUno(posicionJugadores(posicionPokemon(p, pGo), pGo))) = 9 THEN fueraDelMapa ELSE posicionPokemon(p, pGo) FI} FI} FI}

	\tadAxioma{pokemonesAtrapados(j1, moverJugador(j2, c, pGo))}{\IF j1 = j2 THEN pokemonesAtrapados(j1, pGo) ELSE {\IF estaEnRangoDeAtrapar(j1, pGo) THEN {\IF estanEnElMismoRango(posicionJugador(j1, pGo), c, mapa(pGo)) THEN pokemonesAtrapados(j1, pGo) ELSE {\IF cuantoLlevaEsperando(pokemonDelRango(j1, pGo),pGo) = 9 THEN {\IF j1 = dameUno(jugadoresDelRango(posicionPokemon(pokemonDelRango(j1,pGo),pGo),pGo)) THEN definir($\Pi_1$(pokemonDelRango(j1, pGo)), $\Pi_2$(pokemonDelRango(j1, pGo)), pokemonesAtrapados(j1, pGo)) ELSE pokemonesAtrapados(j1, pGo) FI} ELSE pokemonesAtrapados(j1, pGo) FI} FI} ELSE pokemonesAtrapados(j1, pGo) FI} FI}

	$\newline$
	%%% conectar
	\tadAxioma{mapa(conectar(j,c,pGo))}{mapa(pGo)}
	\tadAxioma{jugadores(conectar(j,c,pGo))}{definir(j,conectado,jugadores(pGo))}
	\tadAxioma{posicionJugador(j1,conectar(j2,c,pGo))}{\IF j1 = j2 THEN c ELSE posicionJugador(j1,pGo) FI}
	\tadAxioma{pokemones(conectar(j,c,pGo))}{pokemones(pGo)}
	\tadAxioma{posicionPokemon(p,conectar(j,c,pGo))}{posicionPokemon(p,pGo)}
	\tadAxioma{cuantoLlevaEsperando(p,conectar(j,c,pGo))}{\IF estanEnElMismoRango(posicionPokemon(p),c,mapa(pGo)) THEN 0 ELSE cuantoLlevaEsperando(p,pGo) + 1 FI}
	\tadAxioma{pokemonesAtrapados(j1,conectar(j2,c,pGo))}{\IF j1 = j2 THEN pokemonesAtrapados(j1,pGo) ELSE {\IF estaEnRangoDeAtrapar(j1,pGo) THEN {\IF estanEnElMismoRango(posicionJugador(j1,pGo),c,mapa(pGo)) THEN pokemonesAtrapados(j1,pGo) ELSE {\IF cuantoLlevaEsperando(pokemonDelRango(j1,pGo),pGo)) = 9 THEN {\IF j1 = dameUno(JugadoresDelRango(posicionPokemon(pokemonDelRango(j1,pGo)))) THEN definir($\Pi_1$(pokemonDelRango(j1,pGo)), $\Pi_2$(pokemonDelRango(j1,pGo)), pokemonesAtrapados(j1,pGo)) ELSE pokemonesAtrapados(j1,pGo) FI} ELSE pokemonesAtrapados(j1,pGo) FI} FI} ELSE pokemonesAtrapados(j1,pGo) FI} FI}
	\tadAxioma{cantidadDeSanciones(j1,conectar(j2,c,pGo))}{cantidadDeSanciones(j1,pGo)}
	
	$\newline$
	%%% desconectar
	\tadAxioma{mapa(desconectar(j, pGo))}{mapa(pGo)}
	\tadAxioma{jugadores(desconectar(j, pGo))}{definir(j, Desconectado, jugadores(pGo))}
	\tadAxioma{posicionJugador(j1, desconectar(j2, pGo))}{posicionJugador(j1, pGo)}
	\tadAxioma{pokemones(desconectar(j, pGo))}{pokemones(pGo)}
	\tadAxioma{posicionPokemon(p, desconectar(j, pGo))}{posicionPokemon(p, pGo)}
	\tadAxioma{cuantoLlevaEsperando(p, desconectar(j, pGo))}{cuantoLlevaEsperando(p, pGo)}
	\tadAxioma{pokemonesAtrapados(j1, desconectar(j2, pGo))}{pokemonesAtrapados(j1, pGo)}
	\tadAxioma{cantidadDeSanciones(j1, desconectar(j2, pGo))}{cantidadDeSanciones(j1, pGo)}

%    \tadAxioma{actualizarContadores(cj, c, pGo)}{\IF $\emptyset$?(cj) THEN $\emptyset$ ELSE {\IF posicionJugador(dameUno(cj),pGo) == c THEN Ag(actualizarEspera(true,dameUno(cj)), actualizarContadores(sinUno(cj),c,pGo)) ELSE {\IF esperaParaAtrapar(dameUno(cj)) == 9 THEN unoAtrapa(posicionJugadores(posicionJugador(dameUno(cj),pGo),pGo) $\cup$ actualizarContadores(cj - posicionJugadores(posicionJugador(dameUno(cj),pGo),c,pGo) ELSE Ag(actualizarEspera(false,dameUno(cj)), actualizarContadores(sinUno(cj),c,pGo)) FI} FI} FI}
%

	$\newline$
	%%% otrasOperaciones
	\tadAxioma{esPosicionValidaMapa(c, pGo)}{c $\in$ posiciones(mapa(pGo))}
	\tadAxioma{esPosicionValidaPokemon(c, pGo)}{esPosicionValidaMapa(c, pGo) $\yluego$ (\paratodo p $\leftarrow$ pokemones(pGo), esSalvaje?(p, pGo)) $\neg$ estaEnElRangoDeOtroPokemon(c, posicionPokemon(p, pGo)))}
	\tadAxioma{estaEnElRangoDeOtroPokemon(c1, c2)}{(restaAbsoluta($\Pi_1$(c1), $\Pi_1$(c2))) * (restaAbsoluta($\Pi_1$(c1), $\Pi_1$(c2))) + (restaAbsoluta($\Pi_2$(c1), $\Pi_2$(c2))) * (restaAbsoluta($\Pi_2$(c1), $\Pi_2$(c2)))) $\leq$ 5 * 5}
	
	\tadAxioma{restaAbsoluta(p1, p2)}{\IF p1 $\leq$ p2 THEN p2 - p1 ELSE p1 - p2 FI}
  \tadAxioma{rareza(t, pGo)}{100 - dividir(cantidadPokemones(t,(claves(pokemones(pGo)), pGo), \#claves(pokemones(pGo)))) * 100}
  \tadAxioma{cantidadPokemonesTipo(t, ids, pGo)}{\IF vacio?(ids) THEN 0 ELSE {\IF obtener(dameUno(ids)) == t THEN cantidadPokemonesTipo(t, sinUno(ids), pGo) + 1 ELSE cantidadPokemonesTipo(t, sinUno(ids), pGo) FI} FI}
  \tadAxioma{dividir(n, d)}{\IF n $\geq$ d THEN dividir(n-d, d) + 1 ELSE 0 FI}
    

\end{tad}
