%%%%%%%%%%%%%%%%%%%% Juego
\section{TAD \tadNombre{Juego}}
\begin{tad}{\tadNombre{Juego}}
	\tadGeneros{juego}
	
	%%% Observadores %%%
	\tadObservadores
	\tadAlinearFunciones{cuantoLlevaEsperando~}{Jugador/j, Juego/pGo, Coordenada}
	
    \tadOperacion{mapa}{Juego}{Mapa}{}
    \tadOperacion{jugadores}{Juego}{Jugadores}{}
    \tadOperacion{posicionJugador}{Jugador/j, Juego/pGo}{Coordenada}
    	{def?(j, jugadores(pGo)) $\yluego$ obtener(j, jugadores(pGo))}
    \tadOperacion{pokemones}{Juego}{Pokemones}{}
    \tadOperacion{posicionPokemon}{Pokemon/p, Juego/pGo}{Coordenada}
    		{def?($\Pi_1$(p),pokemones(pGo)) $\yluego$ esSalvaje?(p, pGo)}
    \tadOperacion{cuantoLlevaEsperando}{Pokemon/p, Juego/pGo}{Nat}{def?($\Pi_1$(p),pokemones(pGo)) $\yluego$ esSalvaje?(p, pGo)}
    \tadOperacion{pokemonesAtrapados}{Jugador/j, Juego/pGo}{Pokemones}{def?(j, jugadores(pGo))}
    \tadOperacion{cantidadDeSanciones}{Jugador/j, Juego/pGo}{Nat}{def?(j, jugadores(pGo))}

	%%% Generadores %%%
	\tadGeneradores
	\tadAlinearFunciones{moverJugador~}{Jugador/j, Coordenada/c, Juego/pGo, Juego}
	
    \tadOperacion{nuevoJuego}{Mapa}{Juego}{}{}
    \tadOperacion{agJugador}{Jugador/j, Coordenada/c, Juego/pGo}{Juego}
    	{$\neg$ def?(j, jugadores(pGo)) $\yluego$ esPosicionValidaMapa(c, pGo) }
    \tadOperacion{agPokemon}{Pokemon/p, Coordenada/c, Juego/pGo}{Juego}
    	{$\neg$ def?($\Pi_1$(p),pokemones(pGo)) $\yluego$ esPosicionValidaPokemon(c, pGo)}
    \tadOperacion{moverJugador}{Jugador/j, Coordenada/c, Juego/pGo}{Juego}
    	{def?(j, jugadores(pGo)) $\yluego$ esPosicionValidaMapa(c, pGo)}
    \tadOperacion{conectar}{Jugador/j, Coordenada/c, Juego/pGo}{Juego}{def?(j, jugadores(pGo)) $\yluego$ $\neg$ estaConectado(j,pGo) $\wedge$ esPosicionValidaMapa(c, pGo)}
    \tadOperacion{desconectar}{Jugador/j, Juego/pGo}{Juego}{def?(j, jugadores(pGo)) $\yluego$ estaConectado(j,pGo)}
    %% moverJugador automaticamente se conecta
    	
    %%% Otras Operaciones %%%
    \tadOtrasOperaciones
    \tadAlinearFunciones{esPosicionValidaPokemon~}{Pokemon/p, Jugador/j, Juego/pGo, Juego}
    \tadOperacion{esPosicionValidaMapa}{Coordenada/c, Juego/j}{bool}{}
    \tadOperacion{esPosicionValidaPokemon}{Coordenada/c, Juego/j}{bool}{}
%    \tadOperacion{actualizarContadores}{conj(Jugador)/cj, Coordenada/c, Juego pGo}{conj(Jugador)}{}
%    \tadOperacion{borrarPokemones}{Pokemones/p, conj(Nat)/ids}{Pokemones}{}
%	\tadOperacion{unoAtrapa}{conj(Jugador)/js, Juego/pGo}{conj(Jugador)}{js $\subseteq$ jugadores(pGo)}
%	\tadOperacion{posicionJugadores}{Coordenada/c, Juegao/pGo}{conj(Jugador)}{c $\in$ posiciones(mapa(pGo))}  
	\tadOperacion{esSalvaje?}{Pokemon/p, Juego/pGo}{Bool}{def?($\Pi_1$(p),pokemones(pGo))}    
    \tadOperacion{estaEnRangoDeAtrapar}{Jugador/j, Juego/pGo}{Bool}{def?(j, jugadores(pGo))} %te dice si el jugador esta dentro del rango de algun pokemon
	\tadOperacion{pokemonDelRango}{Jugador/j, Juego/pGo}{Pokemon}{def?(j, jugadores(pGo)) $\yluego$ estaEnRangoDeAtrapar(j,pGo)} %FaltanRestricciones si el j esta en rango de atrapar, te devuelve el pokemon en cuestiÃ³n.    
    \tadOperacion{jugadoresDelRango}{Coordenada/c, Juego/pGo}{Conj(Jugador)}{esPosicionValidaMapa(c, pGo)}
	%%% Axiomas %%%
	\tadAxiomas[\paratodo{Mapa}{m} \paratodo{Jugador}{j,j1,j2} \paratodo{Coordenada}{c} \paratodo{Juego}{pGo} \paratodo{Pokemon}{p} \paratodo{Nat}{n} \paratodo{Tipo}{t}]

	%%% nuevoJuego
	\tadAxioma{mapa(nuevoJuego(m))}{m}
	\tadAxioma{jugadores(nuevoJuego(m))}{$\emptyset$}
	\tadAxioma{pokemones(nuevoJuego(m))}{$\emptyset$}

	%%% agJugador ==> ver si tiene que informar posicion
	\tadAxioma{mapa(agJugador(j, c, pGo))}{mapa(pGo)}
	\tadAxioma{jugadores(agJugador(j, c, pGo))}{Ag(j, jugadores(pGo))}
	\tadAxioma{posicionJugador(j1, agJugador(j2, c, pGo))}{\IF j1 = j2 THEN c ELSE posicionJugador(j1, pGo) FI}
	\tadAxioma{pokemones(agJugador(j, c, pGo))}{pokemones(pGo)}
	\tadAxioma{posicionPokemon(p, agJugador(j, c, pGo))}{posicionPokemon(p, pGo)}
  \tadAxioma{cuantoLlevaEsperando(p,agJugador(j, c, pGo))}{\IF estanEnElMismoRango(posicionPokemon(p,pGo), c, mapa(pGo)) THEN 0 ELSE cuantoLLevaEsperando(p, pGo) + 1 FI} 
  \tadAxioma{pokemonesAtrapados(j1, agJugador(j2, c, pGo))}{\IF j1 == j2 THEN vacio ELSE {\IF estanEnMismoRango(posicionJugador(j1, pGo), c, pGo) THEN pokemonesAtrapados(j1, pGo) ELSE {\IF cuantoLlevaEsperando(pokemonEnRango(rangoDeCaza(j1, pGo), pGo), pGo) = 9 THEN {\IF j1 = dameUno(jugadoresPorAtrapar(pokemonEnRango(rangoDeCaza(j1, pGo), pGo))) THEN definir($\Pi_1$(pokemonEnRango(rangoDeCaza(j1, pGo), pGo)), $\Pi_2$(pokemonEnRango(rangoDeCaza(j1, pGo)), pGo), pokemonesAtrapados(j1, pGo)) ELSE pokemonesAtrapados(j1, pGo) FI} ELSE pokemonesAtrapados(j1, pGo) FI} FI} FI}
  \tadAxioma{cantidadDeSanciones(j1, agJugador(j2, c, pGo))}{\IF j1 == j2 THEN 0 ELSE cantidadDeSanciones(j1) FI}
  
	%%% agPokemon
	\tadAxioma{mapa(agPokemon(n, t, c, pGo))}{mapa(pGo)}
	\tadAxioma{jugadores(agPokemon(n, t, c, pGo))}{jugadores(pGo)}
	\tadAxioma{posicionJugador(j, agPokemon(n, t, c, pGo))}{posicionJugador(j, pGo)}
	\tadAxioma{pokemones(agPokemon(n, t, c, pGo))}{definir(n, t, pokemones(pGo))}
	\tadAxioma{posicionPokemon(p, agPokemon(n, t, c, pGo))}{\IF $\Pi_1$(p) = n THEN c ELSE posicionPokemon(p, pGo) FI}
	
	%%% moverJugador
	\tadAxioma{mapa(moverJugador(j, c, pGo))}{mapa(pGo)}
	%%Agregar movimientoInvalido al tad Mapa
	\tadAxioma{jugadores(moverJugador(j,c,pGo))}{\IF movimientoInvalido(posicionJugador(j,pGo),c,mapa(pGo)) THEN {\IF cantidadDeSanciones(j,pGo) = 9 THEN borrar(j,jugadores(pGo)) ELSE jugadores(pGo) FI} ELSE jugadores(pGo) FI}
	\tadAxioma{posicionJugador(j1, moverJugador(j2,c,pGo))}{\IF j1 = j2 THEN c ELSE posicionJugador(pGo) FI}
	%%sacarPokemones tiene que sacar esas claves de pokemones y devolver el diccionario sin esos pokemones
	\tadAxioma{pokemones(moverJugador(j,c,pGo))}{\IF movimientoInvalido(posicionJugador(j,pGo),c,mapa(pGo)) THEN {\IF cantidadDeSanciones(j,pGo) = 4 THEN sacarPokemones(claves(pokemonesAtrapados(j,pGo)),pGo) ELSE pokemones(pGo) FI} ELSE pokemones(pGo) FI}
	\tadAxioma{posicionPokemon(p,moverJugador(j,c,pGo))}{posicionPokemon(pGo)}
	\tadAxioma{cuantoLlevaEsperando(p,moverJugador(j,c,pGo))}{\IF estanEnElMismoRango(posicionPokemon(p,pGo),posicionJugador(j,pGo),mapa(pGo)) THEN {\IF estanEnElMismoRango(posicionPokemon(p,pGo),c,mapa(pGo)) THEN cuantoLlevaEsperando(p,pGo) ELSE cuantoLlevaEsperando(p,pGo) + 1 FI} ELSE {\IF estanEnElMismoRango(posicionPokemon(p,pGo),c,mapa(pGo)) THEN 0 ELSE cuantoLlevaEsperando(p,pGo) + 1 FI} FI}
	\tadAxioma{cantidadDeSanciones(j1,moverJugador(j2,c,pGo))}{\IF j1 = j2 THEN {\IF movientoInvalido(poscionJugador(j1),c,pGo) THEN cantidadDeSanciones(j1,pGo) + 1 ELSE cantidadDeSanciones(j1,pGo) FI} ELSE cantidadDeSanciones(j1,pGo) FI}	
	%%% ver otra op posicionInvalida, puede ser esPosicionValida declarada arriba
%	\tadAxioma{jugadores(moverJugador(j, c, pGo))}{\IF nula?(c) THEN jugadores(pGo) ELSE actualizarContadores({\IF posicionInvalida(posicionJugador(j, pGo), c, pGo) THEN {\IF cantidadSanciones(j) = 4 THEN jugadores(pGo) - {j} ELSE Ag(sancionar(j), jugadores(pGo) - {j}) FI} ELSE jugadores(pGo) FI}, c, pGo) FI}
%	\tadAxioma{posicionJugador(j1, moverJugador(j2, c, pGo))}{\IF j1 $\neq$ j2 THEN posicionJugador(j1, pGo) ELSE {\IF nula?(c) THEN fueraDelMapa ELSE {\IF nula?(posicionJugador(j2, pGo)) THEN c ELSE {\IF posicionInvalida(c) THEN {\IF cantidadDeSanciones(j1) = 4 THEN fueraDelMapa ELSE c FI} ELSE c FI} FI} FI} FI}
%	\tadAxioma{pokemones(moverJugador(j, c, pGo))}{\IF nula?(c) THEN pokemones(pGo) ELSE {\IF (posicionInvalida(posicionJugador(j, pGo), c, pGo) $\land$ cantidadSanciones(j) = 4) THEN borrarPokemones(pokemones(pGo), claves(pokedex(j))) ELSE pokemones(pGo) FI} FI}
 %   \tadAxioma{borrarPokemones(p, ids}{\IF vacio?(ids) THEN p ELSE borrarPokemones(borrar(dameUno(ids), p), sinUno(ids)) FI}
    
%    \tadAxioma{posicionPokemon(p, moverJugador(j, c, pGo))}{\IF nula?(c) THEN posicionPokemon(p, pGo) ELSE {\IF j $\in$ posicionJugadores(posicionPokemon(p, pGo), pGo) THEN posicionPokemon(p, pGo) ELSE {\IF esperaParaAtrapar(dameUno(posicionJugadores(posicionPokemon(p, pGo), pGo))) = 9 THEN fueraDelMapa ELSE posicionPokemon(p, pGo) FI} FI} FI}

	\tadAxioma{pokemonesAtrapados(j1, moverJugador(j2, c, pGo))}{\IF j1 = j2 THEN pokemonesAtrapados(j1, pGo) ELSE {\IF estaEnRangoDeAtrapar(j1, pGo) THEN {\IF estanEnElMismoRango(posicionJugador(j1, pGo), c, mapa(pGo)) THEN pokemonesAtrapados(j1, pGo) ELSE {\IF cuantoLlevaEsperando(pokemonDelRango(j1, pGo),pGo) = 9 THEN {\IF j1 = dameUno(jugadoresDelRango(posicionPokemon(pokemonDelRango(j1,pGo),pGo),pGo)) THEN definir($\Pi_1$(pokemonDelRango(j1, pGo)), $\Pi_2$(pokemonDelRango(j1, pGo)), pokemonesAtrapados(j1, pGo)) ELSE pokemonesAtrapados(j1, pGo) FI} ELSE pokemonesAtrapados(j1, pGo) FI} FI} ELSE pokemonesAtrapados(j1, pGo) FI} FI}

	%%% conectar
	\tadAxioma{mapa(conectar(j,c,pGo))}{mapa(pGo)}
	\tadAxioma{jugadores(conectar(j,c,pGo))}{jugadores(pGo)}
	\tadAxioma{posicionJugador(j1,conectar(j2,c,pGo))}{\IF j1 = j2 THEN c ELSE posicionJugador(j1,pGo) FI}
	\tadAxioma{pokemones(conectar(j,c,pGo))}{pokemones(pGo)}
	\tadAxioma{posicionPokemon(p,conectar(j,c,pGo))}{posicionPokemon(p,pGo)}
	\tadAxioma{cuantoLlevaEsperando(p,conectar(j,c,pGo))}{\IF estanEnElMismoRango(posicionPokemon(p),c,mapa(pGo)) THEN 0 ELSE cuantoLlevaEsperando(p,pGo) + 1 FI}
	\tadAxioma{pokemonesAtrapados(j1,conectar(j2,c,pGo))}{\IF j1 = j2 THEN pokemonesAtrapados(j1,pGo) ELSE {\IF estaEnRangoDeAtrapar(j1,pGo) THEN {\IF estanEnElMismoRango(posicionJugador(j1,pGo),c,mapa(pGo)) THEN pokemonesAtrapados(j1,pGo) ELSE {\IF cuantoLlevaEsperando(pokemonDelRango(j1,pGo),pGo)) = 9 THEN {\IF j1 = dameUno(JugadoresDelRango(posicionPokemon(pokemonDelRango(j1,pGo)))) THEN definir($\Pi_1$(pokemonDelRango(j1,pGo)), $\Pi_2$(pokemonDelRango(j1,pGo)), pokemonesAtrapados(j1,pGo)) ELSE pokemonesAtrapados(j1,pGo) FI} ELSE pokemonesAtrapados(j1,pGo) FI} FI} ELSE pokemonesAtrapados(j1,pGo) FI} FI}
	\tadAxioma{cantidadDeSanciones(j1,conectar(j2,c,pGo))}{cantidadDeSanciones(j1,pGo)}
	
	%%% desconectar
	\tadAxioma{mapa(desconectar(j, pGo))}{mapa(pGo)}
	\tadAxioma{jugadores(desconectar(j, pGo))}{definir(j, Desconectado, jugadores(pGo))}
	\tadAxioma{posicionJugador(j1, desconectar(j2, pGo))}{posicionJugador(j1, pGo)}
	\tadAxioma{pokemones(desconectar(j, pGo))}{pokemones(pGo)}
	\tadAxioma{posicionPokemon(p, desconectar(j, pGo))}{posicionPokemon(p, pGo)}
	\tadAxioma{cuantoLlevaEsperando(p, desconectar(j, pGo))}{cuantoLlevaEsperando(p, pGo)}
	\tadAxioma{pokemonesAtrapados(j1, desconectar(j2, pGo))}{pokemonesAtrapados(j1, pGo)}
	\tadAxioma{cantidadDeSanciones(j1, desconectar(j2, pGo))}{cantidadDeSanciones(j1, pGo)}

%    \tadAxioma{actualizarContadores(cj, c, pGo)}{\IF $\emptyset$?(cj) THEN $\emptyset$ ELSE {\IF posicionJugador(dameUno(cj),pGo) == c THEN Ag(actualizarEspera(true,dameUno(cj)), actualizarContadores(sinUno(cj),c,pGo)) ELSE {\IF esperaParaAtrapar(dameUno(cj)) == 9 THEN unoAtrapa(posicionJugadores(posicionJugador(dameUno(cj),pGo),pGo) $\cup$ actualizarContadores(cj - posicionJugadores(posicionJugador(dameUno(cj),pGo),c,pGo) ELSE Ag(actualizarEspera(false,dameUno(cj)), actualizarContadores(sinUno(cj),c,pGo)) FI} FI} FI}
%



\end{tad}
